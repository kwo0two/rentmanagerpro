# MCP (My Coding Principles) - AI 코딩 파트너 원칙

이 문서는 AI 코딩 파트너가 이 프로젝트의 코드를 생성하고 수정할 때 따르는 핵심적인 기술 원칙과 표준 시공법(MCP)을 정의합니다. `app-spec.md`가 **무엇(WHAT)**을 만들지 정의하는 설계도라면, 이 문서는 **어떻게(HOW)** 만들지에 대한 시공 지침서입니다.

## 1. Firebase 사용 원칙

### 1.1. 보안 (Security First)

- **보안 규칙 우선:** 모든 Firestore 쿼리는 `firestore.rules`에 정의된 보안 규칙을 통과할 수 있도록 작성합니다. `ownerId`를 사용한 소유권 증명을 기본으로 하며, 복잡한 쿼리 전에는 항상 규칙을 먼저 고려합니다.
- **서버리스 함수 최소화:** 가능한 모든 데이터 조작(CRUD)은 클라이언트 SDK와 보안 규칙을 통해 처리합니다. 서버리스 함수(Cloud Functions)는 보안 규칙으로 표현할 수 없는 복잡한 로직(예: 결제 처리, 외부 API 연동)에만 제한적으로 사용합니다.

### 1.2. 데이터 모델링 및 쿼리

- **비정규화(Denormalization) 활용:** 쿼리 성능 향상을 위해 필요시 데이터를 비정규화합니다. 예를 들어, `leaseAgreements`에 `buildingName`을 함께 저장하여 `buildings` 컬렉션을 매번 참조하는 것을 피합니다.
- **효율적인 쿼리 작성:** `in` 쿼리는 30개 미만의 문서 ID에만 사용하고, 대규모 데이터 조회 시에는 페이지네이션을 구현합니다. 불필요한 `getDocs` 호출을 최소화하고, 실시간 업데이트가 필요할 때만 `onSnapshot`을 사용합니다.
- **상태 관리:** `useCollection`, `useDoc` 훅을 사용하여 Firestore 데이터와 컴포넌트 상태를 실시간으로 동기화합니다. 이 훅에 전달되는 쿼리나 참조는 `useMemoFirebase`를 사용하여 반드시 메모이제이션하여 불필요한 재실행과 무한 루프를 방지합니다.

### 1.3. 데이터 무결성 및 감사

- **중앙화된 업데이트:** 모든 데이터 생성, 수정, 삭제는 `src/firebase/non-blocking-updates.tsx`에 정의된 중앙 함수(`addDocumentNonBlocking`, `updateDocumentNonBlocking` 등)를 통해서만 실행합니다.
- **감사 로그 자동화:** 중앙화된 업데이트 함수 내에서, 모든 주요 데이터 변경 사항에 대한 감사 로그(`logs` 컬렉션)를 자동으로 생성하여 작업의 추적성을 보장합니다.

## 2. React & Next.js 아키텍처

### 2.1. 컴포넌트 설계

- **서버 컴포넌트 우선:** 데이터 조회와 같이 서버에서 처리할 수 있는 작업은 서버 컴포넌트(`'use server'`)를 기본으로 사용하여 클라이언트 측 부담을 줄입니다.
- **클라이언트 컴포넌트 최소화:** `useState`, `useEffect`, 사용자 이벤트 핸들링 등 상호작용이 필수적인 경우에만 클라이언트 컴포넌트(`'use client'`)를 사용합니다.
- **기능별 분리:** 복잡한 UI는 컨테이너(데이터 로직)와 프레젠테이션(UI 렌더링) 컴포넌트로 분리합니다. 예를 들어, `all-tenants-table.tsx`는 데이터 조회 및 가공을, `columns.tsx`는 테이블의 각 셀을 어떻게 보여줄지를 담당합니다.

### 2.2. 상태 관리

- **단순성 유지:** 전역 상태 관리 라이브러리(Redux, Zustand 등) 대신 React의 기본 훅(`useState`, `useContext`)과 서버 상태(데이터)를 조합하여 상태 관리를 단순하게 유지합니다.
- **파생 상태 최소화:** `useMemo`를 적극적으로 사용하여 렌더링 간에 비용이 많이 드는 계산 결과를 메모이제이션하고, 상태로부터 파생될 수 있는 값은 별도의 `useState`로 만들지 않습니다.

## 3. UI/UX 가이드라인

### 3.1. 디자인 시스템

- **ShadCN/UI 활용:** 모든 UI 요소는 `src/components/ui`에 사전 정의된 ShadCN/UI 컴포넌트(Button, Card, Table 등)를 최대한 활용하여 시각적 일관성을 유지합니다.
- **Tailwind CSS:** 스타일링은 Tailwind CSS 유틸리티 클래스를 사용합니다. 커스텀 CSS는 최소화하고, 필요시 `globals.css`에 정의된 테마 변수(`--primary`, `--destructive` 등)를 활용합니다.
- **일관된 사용자 경험:** 삭제, 초기화 등 되돌릴 수 없는 중요한 작업에는 항상 `AlertDialog`를 사용하여 사용자에게 재확인 절차를 제공합니다. 작업의 성공, 실패, 정보 등은 `Toast` 컴포넌트를 통해 일관된 방식으로 피드백합니다.

### 3.2. 에러 핸들링

- **상세한 오류 정보:** Firestore 권한 오류 발생 시, 단순히 "권한 없음" 메시지 대신, `FirebaseErrorListener`와 `FirestorePermissionError`를 통해 어떤 규칙에 의해 어떤 요청이 거부되었는지 상세한 JSON 정보를 화면에 표시하여 디버깅을 용이하게 합니다.
- **사용자 친화적 오류 메시지:** 최종 사용자에게는 기술적인 오류 내용 대신, "데이터를 불러오는 데 실패했습니다."와 같이 이해하기 쉬운 메시지를 `Alert` 컴포넌트를 통해 보여줍니다.

## 4. 코드 품질 및 컨벤션

- **타입스크립트:** 모든 파일은 타입스크립트로 작성하며, `src/lib/types.ts`에 정의된 공유 타입을 사용하여 데이터의 형태를 명확히 하고 타입 안정성을 확보합니다.
- **가독성:** 함수와 변수명은 그 역할이 명확히 드러나도록 작성합니다. 복잡한 로직에는 간결한 주석을 추가하여 의도를 설명할 수 있으나, 코드로 의도가 명확히 드러나는 것을 선호합니다.
- **비동기 처리:** Firestore와의 모든 통신은 비동기(`async/await`)로 처리하며, 로딩 및 오류 상태를 UI에 명확히 표시하여 사용자 경험을 향상시킵니다.
